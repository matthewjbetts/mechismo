#!/usr/bin/perl -w

use strict;
use warnings;
use Carp ();
use Getopt::Long;
use Fist::Schema;
use Dir::Self;
use Config::General;
use Fist::Utils::IdMapping;
use File::Temp;
use Fist::IO::Pdb;
use Fist::IO::Expdta;
use Fist::IO::FragResMapping;
use Fist::IO::Frag;
use Fist::IO::SeqGroup;
use Fist::IO::FragToSeqGroup;
use Fist::IO::Seq;
use Fist::IO::SeqToGroup;
use Fist::IO::Taxon;
use Fist::IO::SeqToTaxon;
use Fist::IO::Alias;
use Fist::IO::Alignment;
use Fist::IO::AlignedSeq;
use Fist::IO::AlignmentToGroup;
use Fist::IO::ChainSegment;
use Fist::IO::Ecod;
use Fist::IO::FragToEcod;
use Fist::IO::FragInst;
use Fist::IO::Contact;
use Fist::IO::ResContact;
use Fist::IO::ContactGroup;
use Fist::IO::ContactToGroup;
use Fist::IO::Hsp;
use Fist::IO::Pmid;
use Fist::IO::ContactHit;
use Fist::IO::ContactHitResidue;
use Fist::IO::ContactHitInterprets;
use Fist::IO::Feature;
use Fist::IO::FeatureInst;
use Fist::IO::FeatureInstContact;
use Fist::IO::PmidToFeatureInst;
use Fist::IO::FragDssp;
use Fist::IO::FragNaccess;
use Fist::IO::FragHit;
use Fist::IO::GoTerm;
use Fist::IO::GoAnnotation;

# options
my $help;
my $dnTmpDefault = '/tmp/';
my $dnTmp = $dnTmpDefault;

# other variables
my $conf;
my $config;
my $schema;
my $id_mapping;
my $io_module;
my $fn;
my $space_str;
my $spaces;
my $space;
my $id_to_space;
my $io;
my $cleanup = 1;
my $tmpdir;
my $tmpfile;
my $name;
my $name_p;
my $key;
my $hashes; # for storing info via given mapping functions
my $time1;
my $time2;
my $time3;

# parse command line
GetOptions(
	   'help'  => \$help,
           'tmp=s' => \$dnTmp,
	  );

defined($help) and usage();
(@ARGV == 0) or usage();

sub usage {
    my($msg) = @_;

    my $prog;
    my $usage;

    ($prog = __FILE__) =~ s/.*\///;

    defined($msg) and warn("\nUsage problem: $msg\n");

    $usage = <<END;

Usage: $prog [options] < input

option  parameter  description                        default
------  ---------  ---------------- ----------------  -------
--help  [none]     print this usage info and exit
--tmp   string     location of tmp directory (useful  $dnTmpDefault
                   if default /tmp/ is too small)

This script merges multiple output files (probably from PBS) and ensures
that IDs are unique and properly referred to in all different objects.
Input is space-separated lines of io_module, filename, and io_spaces.
Entries in files in the same io_space have unique IDs, but they can
be reused in different io_spaces (for example, if the files were
generated by two concurrent processes). This script will make the IDs
unique across all io_spaces and map then where necessary.

If io_space = 'DB' the identifiers will be not be mapped - they should refer
to the same objects as in the database.

END

    # FIXME - add example input

    die $usage;
}

# Merging multiple output files (probably from PBS) and ensuring that
# IDs are unique and properly referred to in all different objects
#
# Pdb.tsv             - no ids, can be loaded as-is
# ResMapping.tsv      - no ids, can be loaded as-is
# Frag.tsv            - map frag->id
# Seq.tsv             - map seq->id
# Alignment.tsv       - map alignment->id
# AlignedSeq.tsv      - map alignment->id and seq->id
# FragToAlignment.tsv - map frag->id and alignment->id
# FragToSeq.tsv       - map frag->id and seq->id
#
# id_old -> id_new is many to one; need to ensure that the each
# id_old is mapped to the correct id_new, i.e. need some way of
# distinguishing them. Best way to do this is to do it in blocks,
# i.e. all files that are in the same id space should be parsed
# at the same time, and then the ID mapping reset.

$conf = Config::General->new(__DIR__ . "/../fist.conf");
%{$config} = $conf->getall;
$schema = Fist::Schema->connect($config->{"Model::FistDB"}->{connect_info}->{dsn}, $config->{"Model::FistDB"}->{connect_info}->{user}, $config->{"Model::FistDB"}->{connect_info}->{password});
$tmpdir = File::Temp->newdir(DIR => $dnTmp, CLEANUP => $cleanup);
$cleanup or print("tmpdir = '$tmpdir'\n");
$id_mapping = Fist::Utils::IdMapping->new(schema => $schema);
$name_p = undef;
$hashes = {};
#$schema->disable_log_bin;
#$schema->disable_foreign_keys;
LINE: while(<STDIN>) {
    (/^#/ or /\A\s*\Z/) and next;
    ($io_module, $fn, $space_str) = split;

    $id_to_space = {};
    $spaces = {};
    if(defined($space_str)) {
        foreach $space (split /,/, $space_str) {
            if($space =~ /(\S+?)=(\S+)/) {
                ($key, $space) = ($1, $2);
                if($space =~ /\A{name=(\S+)}\Z/) {
                    $space = {name => $1, hashes => $hashes};
                    $id_to_space->{$key} = $space;
                    $spaces->{$space->{name}}++;
                }
                else {
                    $id_to_space->{$key} = $space;
                    $spaces->{$space}++;
                }
            }
            else {
                Carp::confess("do not understand space '$space'");
                next LINE;
            }
        }
    }
    $io = $io_module->new(fn => $fn);
    $name = $io->resultset_name;

    if(defined($name_p)) {
        if($io->resultset_name ne $name_p) {
            $schema->enable_keys($name_p);
            $schema->disable_keys($name);
        }
    }
    else {
        $schema->disable_keys($name);
    }

    if((keys(%{$spaces}) > 1) or ((keys(%{$spaces}) == 1) and !defined($spaces->{DB}))) {
        # map IDs and output new temporary tsv
        print "MAPPING $fn ";
        $time1 = time;
        $tmpfile = File::Temp->new(DIR => $tmpdir, UNLINK => $cleanup);
        $cleanup or print("$fn $tmpfile\n");
        $io->tsv_id_map($id_mapping, $id_to_space, $tmpfile);
        $tmpfile->seek(0, SEEK_END);
        $time2 = time;
        printf "time = %d\n", $time2 - $time1;

        $io = $io_module->new(fn => $tmpfile->filename);

        #print "$fn\t$tmpfile\n";
    }

    # load in to db
    print "IMPORT $fn ";
    $time1 = time;
    $io->import_tsv($schema);
    $time2 = time;
    printf "time = %d\n", $time2 - $time1;

    $name_p = $io->resultset_name;
}

$schema->enable_keys($name_p);
#$schema->enable_foreign_keys;
#$schema->enable_log_bin;

